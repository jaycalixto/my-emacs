#+TITLE:    Emacs Configuration
#+AUTHOR:    Sami Airaksinen
#+EMAIL:     samiaira@gmail.com
#+DATE:      2010-04-01 Thu
#+DESCRIPTION: Describing my emacs configuration in self documenting way via org-mode.
#+KEYWORDS:  emacs org configure
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:nil toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:nil
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport notangle
#+LINK_UP:
#+LINK_HOME: 

* Motivation

  Tired to have to copy and reinitialize my emacs environment
  everywhere. Therefore I figured that it might be fun exercise to
  bootstrap my emacs(-configuration) so that it manages itself all
  related packages and dependencies.

  For this purpose I use org-mode format to store and organize my
  configuration code and el-get to manage actual fetching, loading and
  updating of my packages.

* Requirements

  Because this is for my own usage I list here the current working
  environment:
  - Ubuntu 14.04LTS
  - purged distro emacs and its libraries
  - org-mode > 8.2.10 (earlier versions have a bug in the initialization
    function)

* Bootstrapping 						   :external:
  
  #+BEGIN_EXAMPLE
    NOTE: Initial startup can take relatively long time as el-get
    fetches and compilse available recipes from emacswiki
  #+END_EXAMPLE
  
  /I now build emacs from scratch, see 'From scratch' subsection./

  Here are utility scripts that help initialize emacs to vanilla
  environment. Currently I'm only interested in ubuntu environments
  (currently about 12.04).

  #+begin_src shell-script :tangle bootstrap-packages.sh :shebang #!/bin/bash
    echo "bootstarpping emacs 24.1 repositories and installing packages ..."
    sudo add-apt-repository ppa:cassou/emacs 
    sudo apt-get update
    sudo apt-get purge emacs-snapshot-common emacs-snapshot-bin-common emacs-snapshot emacs-snapshot-el emacs-snapshot-gtk emacs23 emacs23-bin-common emacs23-common emacs23-el emacs23-nox emacs23-lucid auctex emacs24 emacs24-bin-common emacs24-common
    sudo apt-get install emacs24 emacs24-el
    
    echo "installing auxialiry debian packages (currently not using el-get to do this)..."
    sudo apt-get install bzr r-base git-svn texinfo ess
  #+end_src

  Here is a little script that helps you to set the repo to be your
  .emacs.d.

  #+begin_src shell-script :tangle bootstrap-configurations.sh :shebang #!/bin/bash
    echo "replacing emacs configuration points in your system, backuping originals..."
    ln -svb $PWD ~/.emacs.d
    ln -svb ~/.emacs.d/personal/.emacs-custom.el ~/.emacs-custom.el
  #+end_src

  As I have my themes as git sub modules I need to initialize them

  #+BEGIN_SRC shell-script :tangle init-configurations.sh :shebang #!/bin/bash
    echo "initializing emacs configurations..."
    git submodule init
    git submodule update
  #+END_SRC

** From scratch							      :build:

   Earlier I used ppa repository and deb packages to resolve used
   emacs and org. But ppa-repository is no longer kept up-to-date so I
   decided built it myself.
   
   #+BEGIN_SRC shell-script :tangle build-emacs.sh :shebang #!/bin/bash
     sudo apt-get build-dep emacs24
     wget http://www.nic.funet.fi/pub/gnu/ftp.gnu.org/pub/gnu/emacs/emacs-24.4.tar.gz
     aunpack emacs-24.4.tar.gz 
     cd emacs-24.4/
     ./configure
     make
     sudo make install
   #+END_SRC

   If I wanna build org-mode myself then,

   #+BEGIN_SRC shell-script :tangle build-org-mode.sh :shebang #!/bin/bash
     git clone git://orgmode.org/org-mode.git
     cd org-mode
     make
     sudo make install
   #+END_SRC

** emacs entry point points

   Environmental file to be sourced so that emacs can be accessed as painlessly as
   possible from terminal.

   #+begin_src shell-script :tangle emacs.env
     # -*- mode: shell-script; -*-
     echo "setting emacs environments..."
      
     VISUAL="emacsclient -c"
     EDITOR="emacsclient -c"
     export VISUAL;
     export EDITOR;
     
     alias mt="emacsclient -t"
     alias m="emacsclient -c"
   #+end_src

* Initialization configurations 				  :loadpaths:
  
  [[file:init.el::%3B%3B%3B%20init.el%20---%20Where%20all%20the%20magic%20begins][All begans here.]] This approach was inspired from documentation of
  org-mode babel library. I use demonized version of the emacs so that
  it only does source tangling and loading of this configuration once.

  #+BEGIN_SRC emacs-lisp
    (defvar personal-directory)
    (setq personal-directory "~/.emacs.d/personal/")
    
    (defun personal-place (suffix)
      (concat personal-directory suffix))
    
    (setq user-full-name "Sami Airaksinen"
          user-email "samiaira@gmail.com")
        
    (add-to-list 'load-path "~/.emacs.d/lib/")
    (add-to-list 'load-path "~/.emacs.d/personal/")
  #+END_SRC

** Packaging manager configurations

   I would like have stuff from MELPA

   #+begin_src emacs-lisp
     (require 'package)
     (setq package-archives '(
                               ("melpa" . "http://melpa.milkbox.net/packages/")
                               ("marmalade" . "http://marmalade-repo.org/packages/")))
   #+end_src

** El-get configurations

   Bootstrapping el-get to my emacs initialization file. Actual
   recipes and el-get lisp files are located in separate git repo as
   sub repo (they are not a same context in my opinion).

   #+begin_src emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/el-get/el-get/")
     (add-to-list 'load-path "~/.emacs.d/el-get/")
     
     (unless (require 'el-get nil 'noerror)
       (with-current-buffer
           (url-retrieve-synchronously
            "https://raw.github.com/dimitri/el-get/master/el-get-install.el")
         (goto-char (point-max))
         (eval-print-last-sexp)))
     
     (add-to-list 'el-get-recipe-path "~/.emacs.d/el-get-user/recipes/")
     
     (defmacro add-to-el-sources(name type after-progn &rest additional)
       `(add-to-list
         'el-get-sources
         (append '(:name ,name :type ,type :after ,after-progn) ',additional)))
   #+end_src

* Emacs encoding 						   :encoding:
  :PROPERTIES:
  :ID:       35debd80-6f3d-497b-9764-9d498a8efbd3
  :END:

  Setting emacs encoding to get correct characters /(reason: maybe some old
  char bug...)/.

  #+BEGIN_SRC emacs-lisp
    (load-library "iso-transl")
    
    (setq
     current-language-environment "UTF-8"
     default-input-method "rfc1345")    
  #+END_SRC 

* Setting key layout 						  :ergoemacs:
  :PROPERTIES:
  :ID:       0b350314-71d4-45a7-975e-a00c723a333f
  :END:
  
  Load ErgoEmacs keybinding and turn the minor mode to be always
  on. This is a sub module in my emacs configrations, see more details
  about this mode from, https://code.google.com/p/ergoemacs/

  #+BEGIN_SRC emacs-lisp
    (add-to-list
     'el-get-sources
     '(:name ergoemacs-keybindings
             :before ;;this is here because keybindings doesn't require log-edit itself
             (progn
               (require 'log-edit))
             :after 
             (progn
               (setq ergoemacs-variant nil)
               (ergoemacs-mode 1)
               (global-set-key (kbd "C-<f5>") 'toggle-truncate-lines)
               (global-set-key (kbd "M-<f5>") 'revert-buffer)
               (global-set-key (kbd "C-S-o") 'dired)
               )))
  #+END_SRC

** Macro keybinding						      :macro:

   Use recommendation from the emacs wiki.

   #+BEGIN_SRC emacs-lisp
     (defun toggle-kbd-macro-recording-on ()
       "One-key keyboard macros: turn recording on."
       (interactive)
       (define-key global-map (this-command-keys)
         'toggle-kbd-macro-recording-off)
       (start-kbd-macro nil))

     (defun toggle-kbd-macro-recording-off ()
       "One-key keyboard macros: turn recording off."
       (interactive)
       (define-key global-map (this-command-keys)
         'toggle-kbd-macro-recording-on)
       (end-kbd-macro))

     (global-set-key '[(f1)] 'call-last-kbd-macro)
     (global-set-key '[(shift f1)] 'toggle-kbd-macro-recording-on)
   #+END_SRC

* Visual appearance 					       :colors:frame:
  :PROPERTIES:
  :tangle: personal/appearance.el
  :END:
 
  #+BEGIN_SRC emacs-lisp
    ;;; appearance.el --- Visual customization and fixes for bugs
    (setq 
     inhibit-startup-screen t
     initial-buffer-choice t
     use-file-dialog nil
     frame-title-format '(buffer-file-name "Emacs: %b (%f)" "Emacs: %b"))
      
    (set-face-attribute 'default nil :height 100 :family "Liberation Mono")
    (show-paren-mode t)
    (column-number-mode t)
    (tool-bar-mode -1)
    
    (add-to-list 'custom-theme-load-path "~/.emacs.d/themes/ujelly")
    (load-theme 'ujelly t)
     
    ;; fixing tool-bar-mode bug in daemon...
    (add-hook 'before-make-frame-hook '(lambda () (tool-bar-mode -1)))
    
  #+END_SRC

** Default frame
   :PROPERTIES:
   :ID:       0b0487c2-c94c-48f5-bcdf-16448183059d
   :END:
   
   This is the configuration creates 80x50 frame in the current
   desktop. It sets colors of cursor, background and foreground. Also
   font is redefined here. Fixes some of the daemon issues.

   #+BEGIN_SRC emacs-lisp
     (setq default-frame-alist
         '((width . 80) (height . 50)
           (cursor-color . "red")
           (foreground-color . "AntiqueWhite2")
           (background-color . "black")
           (vertical-scroll-bars)
           (font . "-raster-Liberation Mono-medium-r-normal-*-*-100-*-*-*-*-*-1")))
   #+END_SRC

** Frame fixing function				      :keys:function:
   :PROPERTIES:
   :ID:       76e18ca4-aa11-4515-8f85-2c27a7b6441a
   :END:
    Function to reset frame to prefixed size.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x W") 'fix-horizontal-size)
     
     (defun fix-frame-horizontal-size (width)
       "Set the frame's size to 80 (or prefix arg WIDTH) columns wide."
       (interactive "P")
       (if window-system
           (set-frame-width (selected-frame) (or width 80))
         (error "Cannot resize frame horizontally: is a text terminal")))
     
     ;; functions to fix buffer window to fixed size
     (defun fix-window-horizontal-size (width)
       "Set the window's size to 80 (or prefix arg WIDTH) columns wide."
       (interactive "P")
       (enlarge-window (- (or width 80) (window-width)) 'horizontal))
     
     ;; actual function to be called
     (defun fix-horizontal-size (width)
       "Set the window's or frame's width to 80 (or prefix arg WIDTH)."
       (interactive "P")
       (condition-case nil
           (fix-window-horizontal-size width)
         (error 
          (condition-case nil
              (fix-frame-horizontal-size width)
            (error
             (error "Cannot resize window or frame horizontally"))))))
     
     ;; modularize this to loadable module
     (provide 'appearance)
   #+END_SRC

** Set font for all						    :ARCHIVE:
   Apparently not used yet...
   #+BEGIN_EXAMPLE
   (if (>= emacs-major-version 23) 
   (modify-all-frames-parameters
   '((font . "Dejavusans"))))   
   #+END_EXAMPLE
* Navigation							      :tramp:
  :PROPERTIES:
  :tangle: personal/navigation.el
  :END:

  Defining navigation preferences. I want easy navigation between
  screens and my mouse cursor to follow wheel motions.

  #+BEGIN_SRC emacs-lisp
    ;;; navigation.el --- navigation modes and customization for them
    
    ;;moving between windows easily
    (when (fboundp 'windmove-default-keybindings)
      (windmove-default-keybindings))
    
    (setq mouse-wheel-follow-mouse t)
    
    (add-to-list
     'el-get-sources
     '(:name saveplace :type builtin :features saveplace 
            :after 
            (progn
              (setq-default save-place t)
              )))
  #+END_SRC

** smex
   Smex is ido for M-x.

   #+BEGIN_SRC emacs-lisp
     (add-to-el-sources 
      smex 
      elpa 
      (progn
        (require 'smex)
        (smex-initialize)
        (setq smex-save-file (personal-place "smex.save"))
        (global-set-key (kbd "M-C-a") 'smex) ;;todo to M-a, replace ergoemacs keybinding
        (global-set-key (kbd "M-C-S-a") 'smex-major-mode-commands)
        ))
   #+END_SRC

** Bookmarks
   Keeping my personal information in one location. 

   #+BEGIN_SRC emacs-lisp
     (setq 
      bookmark-default-file (concat personal-directory "bookmarks")
      bookmark-save-flag 1)
   #+END_SRC
*** Bookmark+
    
    #+BEGIN_SRC emacs-lisp
      (add-to-el-sources 
       bookmark+ 
       builtin 
       (progn))
    #+END_SRC

** ELScreen							   :notangle:
   :PROPERTIES:
   :TANGLE:   no
   :END:

   Elscreen is like screen for emacs. Installed via system tool
   apt-get, so you need sudo rights. It can be passed as $pass env
   variable, but might be little bit unreliable.

   #+BEGIN_SRC emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name elscreen :type apt-get
              :after (progn
                       (global-set-key (kbd "<s-prior>") 'elscreen-previous)
                       (global-set-key (kbd "<s-next>")  'elscreen-next)
                       )))
   #+END_SRC
** Window layout navigator

   Configuring winner mode. With this you can search through your
   previous window layouts.
  
   #+BEGIN_SRC emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name winner :type builtin :features winner
              :after (progn
                       (setq winner-dont-bind-my-keys t) 
                       (global-set-key (kbd "<C-s-left>") 'winner-undo)
                       (global-set-key (kbd "<C-s-right>") 'winner-redo)
                       (winner-mode t)
                       )))
   #+END_SRC

** Trivial modes 						   :external:
   Function to define new trivial modes. This means that buffer is
   opened by external program.

   #+BEGIN_SRC emacs-lisp
     (defun define-trivial-mode(mode-prefix file-regexp &optional command)
       (or command (setq command mode-prefix))
       (let ((mode-command (intern (concat mode-prefix "-mode"))))
         (fset mode-command
               `(lambda ()
                  (interactive)
                  (toggle-read-only t)
                  (start-process ,mode-prefix nil
                                 ,command (buffer-file-name))
                  (kill-buffer (current-buffer))))
         (add-to-list 'auto-mode-alist (cons file-regexp mode-command))))
   #+END_SRC

   These define programs that will launch file when opened

   #+BEGIN_SRC emacs-lisp
     (define-trivial-mode "ooffice" "\\.ods$")
     (define-trivial-mode "evince" "\\.pdf$")
   #+END_SRC

** Dired customization

   Opening files/folders with nautilus from dired buffer.

   #+BEGIN_SRC emacs-lisp
     (defun gnome-open-file (filename)
       "opens the specified file in nautilus."
       (interactive "File to open: ")
       (let ((process-connection-type nil))
         (start-process "" nil "/usr/bin/nautilus" filename)))
     
     (defun dired-gnome-open-file ()
       "Opens the current file in a Dired buffer."
       (interactive)
       (gnome-open-file (dired-get-file-for-visit)))
     
     (add-hook 'dired-mode-hook (lambda () (local-set-key "E" 'dired-gnome-open-file)))
     
     (setq dired-listing-switches "-alh")
   #+END_SRC
** Tramp
   My own configuration to tramp. tramp auto-save should be located to
   my personal folder. Also 'tramping' sudo rights are declared trough
   proxy configuration.

   #+BEGIN_SRC emacs-lisp 
     (add-to-el-sources 
      tramp 
      builtin 
      (progn
        (setq tramp-auto-save-directory (personal-place "tramp-auto-save/")
              tramp-persistency-file-name (personal-place "tramp"))
        (set-default 'tramp-default-proxies-alist (quote ((".*" "\\`root\\'" "/ssh:%h:"))))
        ))
     
     (provide 'navigation)
   #+END_SRC

** Projectile

   Configuration for projectile mode. Eases management of set of files
   that belong to same 'project'

   #+BEGIN_SRC emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name projectile :type elpa :lazy t
              :after (progn
                       (projectile-global-mode)
                       (setq projectile-enable-caching t)
                       )))
   #+END_SRC

* Editing 							   :textedit:
  :PROPERTIES:
  :tangle: personal/editing.el
  :END:

  Configuration relating to actual text editing.

  #+BEGIN_SRC emacs-lisp
    ;;; editing.el --- global edit configurations
    (global-set-key [f4] 'orgstruct-mode)
  #+END_SRC

** Killring modifications.
   New features for copy and cut functions. Non selection applys
   current method to whole line. Also fixes clipboard disconnection
   between X and emacs.

   #+BEGIN_SRC emacs-lisp
     (setq x-select-enable-clipboard t 
           interprogram-paste-function 'x-cut-buffer-or-selection-value)
     
     ;;New kill ring features
     (defadvice kill-ring-save (before slick-copy activate compile)
       "When called interactively with no active region, copy a single
       line instead."
       (interactive 
        (if mark-active (list (region-beginning) (region-end))
          (message  "Copied line") 
          (list (line-beginning-position) 
                (line-beginning-position 2)))))
     
     (defadvice kill-region (before slick-cut activate compile)
       "When called interactively with no active region, kill a single line instead."
       (interactive
        (if mark-active (list (region-beginning) (region-end))
          (list (line-beginning-position)
                (line-beginning-position 2)))))
   #+END_SRC

** yasnippet
   Works, but not with r-autoyas functionality. Could it be some kind
   of version incompatibility.

   #+begin_src elisp
     (add-to-el-sources yasnippet elpa 
                        '(progn
                           (require yasnippet)
                           ;;(yas-minor-mode-on) this triggers some symbol loop error...
                           ))
   #+end_src
   
** Custom tools
   Tools to edit, analyse and manipulate buffer content.
*** Count words
    Count words in the region.

    #+BEGIN_SRC emacs-lisp
      (defun count-words (start end)
        "Print number of words in the region."
        (interactive "r")
        (save-excursion
          (save-restriction
            (narrow-to-region start end)
            (goto-char (point-min))
            (count-matches "\\sw+"))))
    #+END_SRC

*** wc
    wc like function in the emacs.

    #+BEGIN_SRC emacs-lisp
      (defun wc (&optional start end)
        "Prints number of lines, words and characters in region or whole buffer."
        (interactive)
        (let ((n 0)
              (start (if mark-active (region-beginning) (point-min)))
              (end (if mark-active (region-end) (point-max))))
          (save-excursion
            (goto-char start)
            (while (< (point) end) (if (forward-word 1) (setq n (1+ n)))))
          (message "%3d %3d %3d" (count-lines start end) n (- end start))))
    #+END_SRC

*** buffer to PDF
    Copies buffer content to pdf file.

    #+BEGIN_SRC emacs-lisp
      (defun print-to-pdf ()
        (interactive)
        (ps-spool-buffer-with-faces)
        (switch-to-buffer "*PostScript*")
        (write-file "/tmp/tmp.ps")
        (kill-buffer "tmp.ps")
        (setq cmd (concat "ps2pdf14 /tmp/tmp.ps " (buffer-name) ".pdf"))
        (shell-command cmd)
        (shell-command "rm /tmp/tmp.ps")
        (message (concat "Saved to:  " (buffer-name) ".pdf")))
      
      (provide 'editing)
    #+END_SRC

** Undo-Tree

   Visualizing undo history.

   #+BEGIN_SRC emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name undo-tree  
              :after 
              (progn
                (global-undo-tree-mode)
                )))
   #+END_SRC

* Buffers 							     :buffer:
  :PROPERTIES:
  :tangle: personal/buffers.el
  :END:

  Modes and configuration for buffer management.

  #+BEGIN_SRC emacs-lisp
    ;;; buffers.el --- Buffer management customization
  #+END_SRC

** iBuffer filters and grouping 				   :groups:

   Buffer grouping is something that I manage based on computer that
   I'm working on, therefore actual configuration is assumed to be
   present in [[file:personal][personal folder.]] For generating groups I require
   following function to be defined:

   #+BEGIN_SRC emacs-lisp
     (defun ibuffer-create-group-filter (name filters)
       "Utility function to create wanted filter-group."
       (let ((group-filter (list name)))
         (mapc
          (lambda(element)
            (add-to-list 'group-filter (cdr (assoc element ibuffer-filters)) t))
          filters)
         group-filter))
   #+END_SRC

*** Default filters 						    :filters:

    iBuffer mode uses =ibuffer-filters= variable to define available
    filters. Here I define very common ones, special ones can be
    defined and added into variable in a personal configuration files.

    #+BEGIN_SRC emacs-lisp
      (setq ibuffer-filters 
        '(
          ;;mail buffers
          (mail . ("Mail"
                   (or
                    (mode . message-mode)
                    (mode . mail-mode)
                    (mode . wl))))
          ;; Opened manuals
          (woman . ("WoMan"
                    (or
                     (mode . woman-mode)
                     (mode . info-mode))))
          ;; IRC Channels 
          (erc . ("ERC"
                  (mode . erc-mode)))
          ;; Unsorted shells
          (shells . ("Shells"
                     (or
                      (mode . shell-mode)
                      (mode . term-mode)
                      (mode . eshell-mode))))
          ;; all unsorted dired buffers goes here 
          (dired . ("Dired"
                    (mode . dired-mode)))
          ;; all org-related buffers
          (org . ("Org" 
                  (or 
                   (name . "\\*Org *")
                   (mode . org-mode))))
          ;; magit buffers
          (git . ("magit"
                  (name . "\\*magit")))
          (emacs-conf . ("Emacs configuration"
                         (or
                          (filename . "/emacs.seed/")
                          (filename . ".emacs.d/")
                          (filename . "~/.erc-customs.el"))))))
    #+END_SRC

*** Default grouping						     :groups:

    To use ibuffer filters one needs to define grouping based on
    that. Here is the default used in this simple emacs configuration.

    #+BEGIN_SRC emacs-lisp
      (setq ibuffer-saved-filter-groups
            `(,(ibuffer-create-group-filter "default" '(emacs-conf mail erc shells git org dired))))
    #+END_SRC

    Rest of the filter groups can be added into this variable in the
    customization file.

*** Load machine specific grouping			      :load:external:

    Following snippet will load =buffer-grouping= configurations if
    they are present. For selecting the start up grouping I can
    set =ibuffer-startup-filter-group= variable.

    #+begin_src emacs-lisp
      (defvar ibuffer-startup-filter-group "default"
        "startup group that ibuffer uses select initial grouping")

      (load
       (concat personal-directory "buffer-grouping")
       t
       "ibuffer grouping file not found, see that personal/buffer-grouping.el exist")

      (add-hook 'ibuffer-mode-hook
                (lambda()
                  (ibuffer-switch-to-saved-filter-groups ibuffer-startup-filter-group)))
    #+end_src

** Save 							     :backup:
   Using .backups folder as a base folder where to place emacs
   buffers autosave files. Here we also configure my desktop
   recording, which reopens my last buffers when I close and reopen
   my emacs.
   
   #+BEGIN_SRC emacs-lisp
     (add-to-el-sources
      desktop
      builtin
      (progn
         (desktop-save-mode 1)))

     (add-to-el-sources
      savehist
      builtin
      (progn
         (savehist-mode)
         (setq savehist-file (personal-place "savehist-history"))))
        
     (setq
      global-auto-revert-mode t
      make-backup-files t
      backup-directory-alist (quote ((".*" . "~/.backups/emacs.buffers/"))))
   #+END_SRC

** Automatic Cleaning 						   :midnight:
   Keeps my buffer listing reasonable by removing unused buffers. Run
   weekly, because once a day is too often.

   #+BEGIN_SRC emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name midnight :type builtin :features midnight
	      :after
	      (progn
		(setq
		 clean-buffer-list-kill-never-regexps '("\\.org$" "^#" "^!"))
		(run-at-time "23:00" (timer-duration "1 week") 'clean-buffer-list)
		)))
    #+END_SRC

** IDO mode								:ido:
   Library to enhance usability with buffer and directory
   listings. Works mostly in minibuffer area.

   #+BEGIN_SRC emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name ido :type builtin :features ido
              :after
              (progn
                (ido-mode t)
                (setq 
                 ido-ignore-buffers               ; ignore these guys
                 '("\\` " "^\*Mess" "^\*Back" ".*Completion" "^\*Ido")
                 ido-work-directory-list '("~" "~/Documents")
                 ido-case-fold  t                 ; be case-insensitive
                 ido-enable-flex-matching t       ; be flexible
                 ido-max-prospects 6              ; don't spam my minibuffer
                 ido-confirm-unique-completion t) ; wait for RET, even with unique completion
                )
              ))
   #+END_SRC

** Buffer renaming						     :rename:
   When opening a buffer which has same name, this configuration will
   keep buffers unique. It will reorganize names if one the buffers
   has been killed. It will also ignore "system" buffers (starting
   with *-symbol).

   #+BEGIN_SRC emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name uniquify :type builtin :features uniquify
              :after 
              (progn
                (setq 
                 uniquify-buffer-name-style 'post-forward
                 uniquify-separator "::"
                 uniquify-after-kill-buffer-p t
                 uniquify-ignore-buffers-re "^\\*")
                )))
     
     (provide 'buffers)
   #+END_SRC

* Org-mode					      :calendar:organization:
  :PROPERTIES:
  :tangle: personal/org-personal.el
  :END:
  
  Org-mode. This is probably most usefull mode I have ever met. This
  has converted me to be full emacs fanatic and still keeps me
  amazed. This configuration file is powered by org-babel, so you can
  see its power.

  #+BEGIN_SRC emacs-lisp
    ;;; org-personal.el --- personalization to my org
    (require 'org-crypt)
    (setq org-directory "~/org")
  #+END_SRC

** el-get recipe definition				       :elget:recipe:
   :PROPERTIES:
   :tangle:   no
   :END:
   
   #+BEGIN_EXAMPLE
     NOTE: org-mode is bootstrapped to emacs in current configuration. I
     have abandonded idea of managing org-mode trough elpa or el-get.
   #+END_EXAMPLE
   
   This will hook org mode to el-get package manager and trigger
   loading of personal customization. 

   [[id:f85f78c3-6b7d-43a1-bcd1-859e0d48362e][This will added via noweb syntax to emacs.el.]]

   #+name: org-mode-recipe
   #+begin_src emacs-lisp
     (add-to-el-sources
      org
      elpa
      (progn
        (require 'org-personal)
        (require 'org-crypt)))
   #+end_src

** Agenda							     :agenda:

   Agenda is tool for scheduling your events in selected org-buffers,
   so called agenda-files.

   #+BEGIN_SRC emacs-lisp
     (setq 
      org-agenda-start-on-weekday 0 
      org-agenda-show-all-dates t
      org-agenda-tags-column -102
      org-agenda-files (concat org-directory "/agenda.files.txt")
      org-agenda-text-search-extra-files '(agenda-archives)
      org-agenda-time-grid '((daily require-timed)
                             "--------------------"
                             (800 1000 1200 1400 1600 1800 2000 2200))
      org-agenda-todo-ignore-with-date t
      org-agenda-skip-deadline-if-done t
      org-agenda-skip-scheduled-if-done t
      org-agenda-skip-timestamp-if-done t
      org-agenda-repeating-timestamp-show-all t)
      
     (add-hook 'org-agenda-mode-hook '(lambda () (hl-line-mode 1)))
   #+END_SRC

*** To do flow in tasks 					       :todo:

    Here is described how todo keywords are flowd when task is
    progressed. Clocking is triggered to change the tasks
    status. Logging of different state changes are defined in last
    configuration.

    #+BEGIN_SRC emacs-lisp
      (setq 
       org-enforce-todo-dependencies t)
       ;; org-stuck-projects '("LEVEL=2-REFILE-WAITING|LEVEL=1+REFILE/!-DONE-CANCELLED-OPEN" nil ("NEXT") "")

      (let ((simple-seq nil) (work-seq nil) (long-seq nil) (clock-in-f nil) (clock-out-f nil))

            ;; case simple
            ;;TODO STARTED WAITING | DONE DUPLICATE 
            (setq simple-seq '(sequence "TODO(q)" "STARTED(w)" "WAITING(e)" "|" "DONE(r!/@)"))
                  
            ;; case work thing
            ;;GROOMING READY STARTED ONHOLD PR | INMASTER DUBLICATE WONTFIX REJECTED
            (setq work-seq '(sequence "GROOMING(a)" "READY(s)" "INPROGRESS(d)" "ONHOLD(f@)" "PR(g!)" "|" "INMASTER(h!)" "DUBLICATE(j@)" "WONTFIX(k@)" "REJECTED(l@)"))
            
            ;; case long polling state (no need for logging time)
            ;;OPEN EXT-DEPS | CLOSED AQUIRED
            (setq long-seq '(sequence "OPEN(z)" "EXT-DEPS(x@)" "|" "CLOSED(c!)" "AQUIRED(v!)"))

            ;; only use clock states at the lowest level tasks (i.e. simple sequence)  
            (setq clock-in-f (lambda (state) 
                                       (cond
                                        ((string= state "TODO") "STARTED")
                                        ((string= state "WAITING") "STARTED"))))
            
            (setq clock-out-f (lambda (state) 
                                       (cond
                                        ((string= state "STARTED") "WAITING"))))
            
            (setq org-todo-keywords (list simple-seq work-seq long-seq)
                  org-clock-in-switch-to-state clock-in-f
                  org-clock-out-switch-to-state clock-out-f))
    #+END_SRC    

**** Show TODO children of the headline 			   :function:

     Define function that lists TODOs in current subtree.

     #+BEGIN_SRC emacs-lisp
       (defun org-show-todo-children ()
         (interactive)
         (org-narrow-to-subtree)
         (org-show-todo-tree nil)
         (widen))
     #+END_SRC

*** Time and date 
    :PROPERTIES:
    :ID:       7869dadb-9b6b-4cee-a533-67b66f68b95a
    :END:
    
    Here I set custom properties for my clocking efforts and customize
    my time and date options.

    #+BEGIN_SRC emacs-lisp
      (setq 
       org-deadline-warning-days 15
       org-drawers '("PROPERTIES" "LOGBOOK" "CLOCK")
       org-clock-into-drawer "CLOCK"
       org-clock-out-remove-zero-time-clocks t
       org-clock-persist 'history
       org-global-properties '(("Effort_ALL" . "0:10 0:30 1:00 2:00 3:00 4:00 5:00 6:00 7:00 8:00 10:00 20:00 50:00"))
       org-log-into-drawer t
       ;; org-clock-sound "/usr/local/lib/alert1.wav"
       org-log-done 'time)
    #+END_SRC

*** Icalendar Exporting
    :PROPERTIES:
    :ID:       53deba29-b662-4d4b-85e8-1abb548ce317
    :END:

    This configurations defines region and user specific properties to
    potential exports in .ics format of the agenda view.

    #+BEGIN_SRC emacs-lisp
      (setq
       org-icalendar-categories '(all-tags)
       org-icalendar-combined-name "Sami Airaksinen"
       org-icalendar-include-body 500
       org-icalendar-include-todo t
       org-icalendar-store-UID t
       org-icalendar-timezone "Europe/Helsinki"
       org-icalendar-use-deadline '(todo-due event-if-todo event-if-not-todo)
       org-icalendar-use-scheduled '(todo-due event-if-todo event-if-not-todo))
    #+END_SRC

** Babel							:programming:

   Babel enables source code evaluation of many different languages
   inside the org mode buffer. Evolution is fast and current version
   enables at least following features:
   - interactive code editing inside the org-mode buffer
   - source code evaluation with I/O redirection
   
   #+BEGIN_SRC emacs-lisp
     (org-babel-do-load-languages 
      'org-babel-load-languages
      '(
        (octave . t)
        (R . t)
        (dot .t)
        (shell . t)
     ))

     (setq org-src-ask-before-returning-to-edit-buffer nil)
     (setq org-src-window-setup 'current-window)

     (setq org-src-fontify-natively t) ;;set fontify by default on, lets see if I like it

     (add-to-list 'org-src-lang-modes (quote ("dot" . graphviz-dot)))


     ;;(setq org-confirm-babel-evaluate nil) could be a function....
     ;;(define-key org-src-mode-map "\C-s" 'org-edit-src-save)
   #+END_SRC

** Block Wrapping function					   :function:
   
   Inserts marked region between org-mode custom block, interactive.

   #+BEGIN_SRC emacs-lisp
     (defun org-block-wrap-region(start end)
       "Wraps current region between predefined prefix-endfix strings. by: Sami Airaksinen"
       (interactive "r")
       (let ((markup (read-string "define markup: " nil nil '("SRC" "EXAMPLE" "LaTeX" "CENTER" "QUOTE" "VERSE"))) 
             (start-region-char (if (eq (char-after start) ?\n) nil "\n"))
             (end-region-char (if (eq (char-before end) ?\n) nil "\n")))
         (let ((start-mark (concat "#+BEGIN_" markup start-region-char)) (end-mark (concat end-region-char "#+END_" markup)))
           ;; adding to end
           (goto-char end)
           (insert end-mark)
           ;; adding to start
           (goto-char start)
           (insert start-mark))))
   #+END_SRC

** Buffer Encryptions						 :encryption:
   
   Forcing encryption for headlines that have encrypt tag. 
   
   *UPDATE* : <2012-09-15 Sat> 

   Currently require of org-crypt is moved outside of this module, [[*Loading%20of%20different%20aspects][see
   here]].

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-save-all-org-buffers '(lambda() org-encrypt-entries))
   #+END_SRC

** Column mode							     :column:
   
   Org modes column face. Layouts headline at its childs to fixed
   table where you can edit easily its properties. 

   #+BEGIN_SRC emacs-lisp
     (setq
      org-columns-default-format "%50ITEM(Task) %7TODO(ToDo) %10TAGS(Context) %10Effort(Effort){:} %10CLOCKSUM")
     ; org-columns-modify-value-for-display-function '(lambda (column-title value)
     ;                                                  nil))
   #+END_SRC

*** DONE Font change prevention						:BUG:
    CLOSED: [2011-04-21 Thu 17:38]
    :LOGBOOK:
    - State "DONE"       from ""           [2011-04-21 Thu 17:38]
    :END:
    
    Make sure that a fixed-width face is used when we have a column
    table. This occurs if emacs daemon is used.

    #+BEGIN_SRC emacs-lisp
      (when (and (fboundp 'daemonp) (daemonp))
        (add-hook 
         'org-mode-hook 
         '(lambda ()
            (when (fboundp 'set-face-attribute)
              (set-face-attribute 
               'org-column nil
               :height (face-attribute 'default :height)
               :family (face-attribute 'default :family))))))
    #+END_SRC

** Exporting 							      :latex:
   :LOGBOOK:
   - State "QUOTE"      from ""           [2011-04-20 Wed 22:35]
   :END:
   
   Org-mode enables exports to different common formats. 

*** Latex							  :templates:
    
    Latex exports needs header templates and conversion rules for
    headlines.

    Setting default packages so that they don't conflict with some of
    my commonly used packages, see 

    #+BEGIN_SRC emacs-lisp :results silent
      (setq org-latex-default-packages-alist '(("AUTO" "inputenc" t)
                                               ("OT1" "fontenc" t)
                                               ("" "fixltx2e" nil)
                                               ("" "graphicx" t)
                                               ("" "longtable" nil)
                                               ("" "float" nil)
                                               ("" "wrapfig" nil)
                                               ("normalem" "ulem" t)
                                               ("" "textcomp" t)
                                               ("" "marvosym" t)
                                               ("nointegrals" "wasysym" t)
                                               ("" "latexsym" t)
                                               ("" "amssymb" t)
                                               ("" "amstext" nil)
                                               ("" "hyperref" nil)
                                               "\\tolerance=1000"))
    #+END_SRC

    And then we define basic templates for my latex exports.

    #+BEGIN_SRC emacs-lisp
      (setq org-export-latex-Image-default-option "width=hsize"
       org-latex-classes '(
                                  ;; article
                                  ("article" "\\documentclass[12pt,a4paper]{article}
      \\usepackage[utf8]{inputenc}
      \\usepackage[T1]{fontenc}
      \\usepackage{graphicx}
      \\usepackage[pdftex]{hyperref}"
                                   ("\\section{%s}" . "\\section*{%s}")
                                   ("\\subsection{%s}" . "\\subsection*{%s}") 
                                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}") 
                                   ("\\paragraph{%s}" . "\\paragraph*{%s}") 
                                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")) 
                                  ;; report
                                  ("report" "\\documentclass[12pt,a4paper]{report}
      \\usepackage[utf8]{inputenc}
      \\usepackage[T1]{fontenc}
      \\usepackage{graphicx}
      \\usepackage{hyperref}" 
                                   ("\\part{%s}" . "\\part*{%s}") 
                                   ("\\chapter{%s}" . "\\chapter*{%s}") 
                                   ("\\section{%s}" . "\\section*{%s}") 
                                   ("\\subsection{%s}" . "\\subsection*{%s}") 
                                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
                                  ;; book
                                  ("book" "\\documentclass[12pt,a4paper]{book}
      \\usepackage[utf8]{inputenc}
      \\usepackage[T1]{fontenc}
      \\usepackage{graphicx}
      \\usepackage{hyperref}" 
                                   ("\\part{%s}" . "\\part*{%s}") 
                                   ("\\chapter{%s}" . "\\chapter*{%s}") 
                                   ("\\section{%s}" . "\\section*{%s}")
                                   ("\\subsection{%s}" . "\\subsection*{%s}") 
                                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")) 
                                  ;; thesis, TODO this could be extracted to thesis buffer??
                                  ("thesis" "\\documentclass[12pt,a4paper,oneside,pdftex]{report}
      \\usepackage[english, finnish]{babel}
      \\usepackage{listings}
      \\usepackage{subfigure}
      \\usepackage[medium]{titlesec}"
                                   ("\\chapter{%s}" . "\\chapter*{%s}") 
                                   ("\\section{%s}" . "\\section*{%s}")
                                   ("\\subsection{%s}" . "\\subsection*{%s}") 
                                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
                                  ;; astronomy article
                                  ("aa" "\\documentclass[structabstract]{aa}
      \\usepackage{txfonts}
      \\usepackage{graphicx}
      \\usepackage{longtable}
      \\usepackage{hyperref}
      \\usepackage{natbib} 
      \\bibpunct{(}{)}{;}{a}{}{,}" 
                                   ("\\section{%s}" . "\\section*{%s}") 
                                   ("\\subsection{%s}" . "\\subsection*{%s}") 
                                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}") 
                                   ("\\paragraph{%s}" . "\\paragraph*{%s}") 
                                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
       org-format-latex-header "\\documentclass[a4paper]{article}
      \\usepackage{amssymb}
      \\usepackage{amsmath}
      \\usepackage{latexsym}
      \\usepackage{fullpage}
      \\pagestyle{empty}
      \\usepackage[mathscr]{eucal}
      \\usepackage[usenames]{color}")
    #+END_SRC

** Global keybindings 						       :keys:

   The following key strokes are highly used and we want them to be
   accessible from whole system.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c a") 'org-agenda)
     (global-set-key (kbd "C-c l") 'org-store-link)
   #+END_SRC

** Headline Editing						       :edit:

   Here will be configurations relating to Task refiling and archiving.

   #+BEGIN_SRC emacs-lisp
     (setq
      org-archive-location "archive/%s_archive::"
      org-refile-targets '((org-agenda-files . (:maxlevel . 2))))
   #+END_SRC   

*** Capture 						      :remember:keys:
   
   Org-capture enables fast note taking. With a key stroke I can start
   taking complex note with different instant configuration options.

   #+BEGIN_SRC emacs-lisp
     (setq 
      org-default-notes-file (concat org-directory "/notes.org")
      org-reverse-note-order t
      org-capture-templates
      '(
        ("t" "Task (to endless queue)"
         entry
         (file+headline "refile.org" "Tasks") 
         "* TODO %^{task}\t%^G\n   (creation: %u @ %a)\n\n  %i%?" :empty-lines-after 2)
        ("b" "Bug Report (take quick note, copies active region into example region)"
         entry
         (file+headline "refile.org" "Bug Reports") 
         "* %^{bug report title}\t:BUG:\n   (creation: %u @ %a)\n\n   #+BEGIN_EXAMPLE\n     %i\n   #+END_EXAMPLE\n%?" :prepend t)
        ("c" "Capture (take quick note, copies active region)"
         entry
         (file+headline "notes.org" "Capture") 
         "* %^{capture label}\n   (creation: %u @ %a)\n\n   %i %?" :prepend t)
        ("m" "Meeting (mark the calendar)"
         entry
         (file+headline "refile.org" "Meetings") 
         "* %^{occasion}\n%^{at time}T @ %^{where}\n   (creation: %u @ %a)\n\n%i\n%a%?" :prepend t)
        ("n"
         "Note (free flow, jump right in)"
         entry
         (file+headline "refile.org" "Ideas")
         "* %?\n   (creation: %u @ %a)\n   %i" :prepend t :immediate-finish t :jump-to-captured t)))

     (global-set-key (kbd "C-c r") 'org-capture)
   #+END_SRC

** Hooks							       :hook:
   
   Defines org general mode hook that is applied when mode is
   started. Here you can configure your environment even further.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook '(lambda ()
        (flyspell-mode 1)
        (local-set-key (kbd "<f5>") 'org-agenda)
	(local-set-key (kbd "C-c b") 'org-iswitchb)
        (local-set-key (kbd "C-c W") 'org-block-wrap-region)))
   #+END_SRC

** Images in Buffers 						      :image:
   
   Minor mode that shows images directly in the org-buffer.

   #+BEGIN_SRC emacs-lisp
     ;; enable image mode first
     (iimage-mode)
     
     ;; add the org file link format to the iimage mode regex
     (add-to-list 'iimage-mode-image-regex-alist
       (cons (concat "\\[\\[file:\\(~?" iimage-mode-image-filename-regex "\\)\\]")  1))
     
     ;; function to setup images for display on load
     (defun org-turn-on-iimage-in-org ()
       "display images in your org file"
       (interactive)
       (turn-on-iimage-mode)
       (set-face-underline-p 'org-link nil))
     
     ;; function to toggle images in a org bugger
     (defun org-toggle-iimage-in-org ()
       "display images in your org file"
       (interactive)
       (if (face-underline-p 'org-link)
           (set-face-underline-p 'org-link nil)
           (set-face-underline-p 'org-link t))
       (call-interactively 'iimage-mode))
     
     ;;  add a hook so we can display images on load
     (add-hook 'org-mode-hook '(lambda () (org-turn-on-iimage-in-org)))
   #+END_SRC

** Linking							       :link:
   
   Linking is essential part of usefulness of org-mode. Buffers can
   form effective data structure for your daily organizational
   information. Here is configuration how links can be used.

   #+BEGIN_SRC emacs-lisp
     (setq org-link-abbrev-alist
           '(("google" . "http://www.google.com/search?q=")
             ("wiki" . "http://en.wikipedia.org/wiki/")))
   #+END_SRC

** Mobile-org 							     :mobile:
   SCHEDULED: <2010-08-27 Fri>
   :LOGBOOK:
   - State "WAITING"    from "WAITING"    [2010-08-26 Thu 22:57] \\
     should be finnished next time.
   - State "DONE"       from "STARTED"    [2010-08-26 Thu 22:57]
   - State "STARTED"    from "TODO"       [2010-08-26 Thu 22:57]
   :END:

   Configure MobileOrg.
   
   #+BEGIN_SRC emacs-lisp
     (setq 
      org-mobile-directory "~/org/MobileOrg"
      ;; Set to the name of the file where new notes will be stored
      org-mobile-inbox-for-pull "~/org/MobileOrg/mobile-flagged.org")     
   #+END_SRC
** Tags 							       :tags:
   
   Most frequently tags. I have couple of exclusive tag groups so if I
   change the tag it will remove other group tag automatically.

   #+BEGIN_SRC emacs-lisp
     (setq 
      org-tag-alist
      '(
        ;; provisioning type tags
        (:startgroup) ("sales" . ?S) ("client" . ?C) ("core" . ?O) (:endgroup)
        ;; work unit types
        (:startgroup) ("epic" . ?E) ("feature" . ?F) ("bug" . ?B) ("refactor" . ?R) ("debt" . ?D) (:endgroup)
        ;; work related 
        ("debug" . ?d)
        ("log" . ?l)
        ("audit" . ?a)
        ("meeting_note" . ?m)
        ("AP" . ?p)

        ;; other
        ("FLAGGED" . ?f)
        ("code" . ?c)
        ("build" . ?b)
        ("study" . ?s)
        ("emacs" . ?e)
        ("org" . ?o)))

     ;; modularize this personalization
     (provide 'org-personal)
   #+END_SRC

* Mails 						      :communication:
  :PROPERTIES:
  :tangle:   personal/mailing.el
  :END:
** sending mail

   Remember that you need those configuration files to your personal/
   folder.
   
   #+BEGIN_SRC emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name smtpmail-multi :type elpa
              :after 
              (progn
                (require 'smtpmail-multi)
                (require 'personal-smtp-mail-configurations nil 'no-error)
                (add-hook 'mail-mode-hook 'orgstruct-mode))))
     
     (provide 'mailing)
   #+END_SRC

* ERC-client 						      :communication:
  :PROPERTIES:
  :tangle: personal/erc-customs.el
  :END:
  
  ERC is emacs mode for IRC communications.

  #+BEGIN_SRC emacs-lisp
    ;;; erc-customs.el --- Personal customization for ERC package
    (add-to-el-sources
     erc
     builtin
     (progn
       (setq 
        erc-max-buffer-size 30000
        erc-truncate-buffer-on-save t
        erc-notice-highlight-type (quote all)
        erc-notice-prefix ">>>> "
        erc-prompt "WRITE HERE> "
        erc-auto-query 'window-noselect)
    
       ;;enable autojoin
       (erc-autojoin-mode t)
    
       ;;define some custom hook to truncate erc buffers correctly
       (defvar erc-insert-post-hook)
       (add-hook 'erc-insert-post-hook 'erc-truncate-buffer))
     :features erc)
  #+END_SRC

** Bouncer and Identification					:irc:bouncer:
   :PROPERTIES:
   :ID:       a8dfc038-6065-43e1-a222-71ed8b9a74bb
   :END:
   
   Define macro for creating Bouncer connection function.  

   #+BEGIN_SRC emacs-lisp
     ;;define bouncer connection tool
     (defmacro asf-erc-bouncer-connect (command server port nick ssl pass)
       "Create interactive command `command', for connecting to an IRC server. The
        command uses interactive mode if passed an argument."
       (fset command
             `(lambda (arg)
                (interactive "p")
                (if (not (= 1 arg))
                    (call-interactively 'erc)
                  (let ((erc-connect-function ',(if ssl 
                                                    'erc-open-ssl-stream
                                                  'open-network-stream)))
                    (erc :server ,server :port ,port :nick ,nick :password ,pass))))))
    #+END_SRC
*** TODO Login proxies						:proxy:login:
    - redo these tools
      - [ ] hide intermediate functions
      - [ ] hide proxy macro defun 
      - [ ] bouncers are red and regenerated from file each time
        erc-bouncer-login is called

    Here we define connections to my IRC-server. Server connections
    are opened via already available ssh tunnel (provided by gSTM).

    Alternative handling strategies
    - different Tunnel manager or,
    - tunneling with emacs commands
    - opening ports from router for irssi-proxies

    #+BEGIN_SRC emacs-lisp
      ;; create connection functions to my irssi-proxy
      ;; !! NOTE MESSAGES UNENCRYPTED !!!  
      (setq erc-registered-bouncers '())
      
      (defun erc-add-bouncer (key bouncer)
        "Adds bouncer with key to alist if not exists."
        (setq erc-registered-bouncers (add-to-list 'erc-registered-bouncers `(,key . ,bouncer) nil 
              (lambda (o1 o2)
                (equal (car o1) (car o2))))))
      
      (defun erc-get-bouncers ()
        erc-registered-bouncers)
      
      (defun erc-read-bouncer-properties (file)
        (load file))
      
      (defun erc-bouncer-login ()
        "Make connection with each registered bouncer connection."
        (interactive)
        (mapc
         (lambda (current)
           (funcall (cdr current)))
           (erc-get-bouncers)))
      
      (defun erc-create-and-register-bouncers (bouncers)
        "Creates bouncers for each element in bouncers
      list. Assumes that properties are red for each symbol. ssl
      not working at the moment."
        (mapc
         (lambda (current)
           (erc-add-bouncer current (let  ((name 'current) 
                                            (host (get current :host)) 
                                            (port (get current :port))
                                            (user (get current :user))
                                            (ssl (get current :ssl))
                                            (passwd (get current :passwd)))
                                      `(lambda ()
                                         (erc :server ,host :port ,port :nick ,user :password ,passwd)))))
                                      bouncers))
      
      ;; setting login command for erc to my proxy 
      (global-set-key [f2] 'erc-bouncer-login)
      
      (erc-read-bouncer-properties (personal-place ".erc-bouncers.el"))
      
      (erc-create-and-register-bouncers '(erc-irssi-ircnet
                                          erc-irssi-linknet
                                          erc-irssi-freenode))
    #+END_SRC
** IRC custom commands					      :proxy:backlog:
   :PROPERTIES:
   :ID:       f77a3833-9ce6-4e21-975f-fa3e95a74dfb
   :END:   
   With this I will send ctcp message to my proxy which will feed me
   the current backlog.

   #+BEGIN_SRC emacs-lisp
     (defun erc-cmd-BACKLOG ()
       (erc-send-ctcp-message "-proxy-" "IRSSIPROXY BACKLOG SEND"))
     
     ;; module for my erc customs  
     (provide 'erc-customs)
   #+END_SRC
* Programming 								:dev:
  :PROPERTIES:
  :tangle: personal/programming.el
  :END:
  Here be things related to building software. 

  #+BEGIN_SRC emacs-lisp
    ;;; programming.el --- different programming language mode configurations 
    
    (add-to-list
      'el-get-sources
      '(:name rainbow-delimiters
              :after (progn
                       (require 'rainbow-delimiters)
                       (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
                       (add-hook 'ess-mode-hook 'rainbow-delimiters-mode))))
    
    (add-to-list 
      'el-get-sources
      '(:name highlight-parentheses
              :after (progn
                       (require 'highlight-parentheses)
                       (add-hook 'ess-mode-hook 'highlight-parentheses-mode)
                       (add-hook 'prog-mode-hook 'highlight-parentheses-mode))))
    
    (add-to-list
     'el-get-sources
     '(:name yasnippet 
             :after
             (progn
               (yas-global-mode 1))))
    
    (add-to-list
     'el-get-sources
     '(:name smartparens :type elpa :lazy t
             :after (progn
                      (require 'smartparens-config)
                      (smartparens-global-mode))))
    
    ;(add-to-list
    ; 'el-get-sources
    ; '(:name chm-view :features chm-view))
    
    (add-to-el-sources
     pabbrev
     elpa
     (progn
       (require 'pabbrev)))
    
    ;;optionally loading if found
    (require 'ess-site nil 'no-error)
    
    (setq font-lock-maximum-decoration t)
    (global-font-lock-mode t)
  #+END_SRC

** Statistical

   #+BEGIN_SRC emacs-lisp
     (add-to-list 
      'el-get-sources 
      '(:name ess 
              :after (progn
                     (add-to-list 'auto-mode-alist '("\\.R$" . R-mode)))))
   #+END_SRC

** LaTeX

   I need AUCTEX mode for my latex editing.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'el-get-sources '(:name auctex))
   #+END_SRC

** Compilation shell output
   Settings of a compile output buffer/window

   #+BEGIN_SRC emacs-lisp
     (global-set-key [f11] 'compile)
     (global-set-key [f12] 'recompile)
     
     (setq compilation-scroll-output t
           compilation-window-height 16)
   #+END_SRC
** Folding mode

   Enable code block folding as minor-mode, should define those
   folding modes and markups.

   #+BEGIN_SRC emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name folding :after
              (progn
                (folding-add-to-marks-list 'haskell-mode "--{{{"  "--}}}"  nil t)
                (folding-mode-add-find-file-hook)
                (add-hook 'haskell-mode-hook 'folding-mode)
                )))
   #+END_SRC
   
** C

   #+BEGIN_SRC emacs-lisp
     ;;C-hook
     (add-hook 'c-mode-hook
       (lambda ()
         (font-lock-add-keywords nil
           '(("^[^\n]\\{80\\}\\(.*\\)$" 1 font-lock-warning-face t)))))
   #+END_SRC

** Fortran F90

   #+BEGIN_SRC emacs-lisp
     ;; g95 to compilation mode
     (eval-after-load "compile"
       '(setq compilation-error-regexp-alist
              (cons '("^In file \\(.+\\):\\([0-9]+\\)" 1 2)
                    compilation-error-regexp-alist))) 
   #+END_SRC

** XREF 							   :notangle:
   :PROPERTIES:
   :tangle:   no
   :END:

   Xrefactory configuration part

   #+BEGIN_SRC emacs-lisp
     ;; some Xrefactory defaults can be set here
     (defvar xref-current-project nil) ;; can be also "my_project_name"
     (defvar xref-key-binding 'none) ;; can be also 'local or 'none
     
     (setq load-path (cons "/usr/lib/emacs/xref/emacs" load-path))
     (setq exec-path (cons "/usr/lib/emacs/xref/" exec-path))
     
     (load "xrefactory")
     
     ;; end of Xrefactory configuration part ;;
     (message "xrefactory loaded")
   #+END_SRC

** JDEE 							   :notangle:
   :PROPERTIES:
   :tangle:   no
   :END:

   #+BEGIN_SRC emacs-lisp
     ;;JDEE configure
     
     ;; add to list JDEE stuff
     (add-to-list 
      'load-path (expand-file-name "/usr/local/jdee/jde-2.3.5.1/lisp"))
     
     (add-to-list 
      'load-path (expand-file-name "/usr/local/jdee/cedet-1.0beta3b/common"))
     
     (add-to-list 
      'load-path (expand-file-name "/usr/share/emacs/site-lisp/elib"))
     
     (load-file (expand-file-name "/usr/local/jdee/cedet-1.0beta3b/common/cedet.el"))
     
     ;; If you want Emacs to defer loading the JDE until you open a 
     ;; Java file, edit the following line
     (setq defer-loading-jde nil)
     ;; to read:
     (setq defer-loading-jde t)
     (if defer-loading-jde
         (progn
           (autoload 'jde-mode "jde" "JDE mode." t)
           (setq auto-mode-alist
              (append
               '(("\\.java\\'" . jde-mode))
               auto-mode-alist)))
       (require 'jde))
     
     ;;set some jde variables
     (setq jde-jdk (quote ("sun 1.6.0.10"))
           jde-jdk-registry (quote (("sun 1.6.0.10" . "/usr/lib/jvm/java-6-sun-1.6.0.10/") ("open 1.6.0" . "/usr/lib/jvm/default-java"))))
     
     ;; Sets the basic indentation for Java source files
     ;; to two spaces.
     (defun my-jde-mode-hook ()
       (setq c-basic-offset 3))
     
     ;;make mode-hook
     (add-hook 'jde-mode-hook 'my-jde-mode-hook)
   #+END_SRC
** Maven

   Enables simple POM property parsing and connection to JDE mode.

   #+begin_src emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name pom))
   #+end_src
** Sage 							   :notangle:
   :PROPERTIES:
   :tangle:   no
   :END:

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path (expand-file-name "$SAGE_DATA/emacs"))
     (require 'sage "sage")
     (setq sage-command "$SAGE_ROOT/sage")
     
     ;; If you want sage-view to typeset all your output and have plot()
     ;; commands inline, uncomment the following line and configure sage-view:
     (require 'sage-view "sage-view")
     (add-hook 'sage-startup-hook 'sage-view)
     You can use commands like
     (add-hook 'sage-startup-hook 'sage-view
     'sage-view-disable-inline-output 'sage-view-disable-inline-plots)
     ;; to have some combination of features.  In future, the customize interface
     ;; will make this simpler... hint, hint!
   #+END_SRC
** Ruby

   #+BEGIN_SRC emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name ruby-mode :features ruby-mode ;'(ruby-mode ruby-electric)
              :after
              (progn
                (add-to-list 'interpreter-mode-alist '("ruby" . ruby-mode)) 
                (add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
                (defun ruby-eval-buffer () 
                  (interactive)
                  "Evaluate the buffer with ruby."
                  (shell-command-on-region (point-min) (point-max) "ruby"))
                (add-hook 'ruby-mode-hook 
                          (lambda ()
                            (setq standard-indent 4)
                            (pabbrev-mode t)
                            ;;(ruby-electric-mode t)
                            (define-key ruby-mode-map "\C-c\C-a" 'ruby-eval-buffer)))
                )))
   #+END_SRC

** Php
   For debugging php files.

   #+begin_src emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name php-mode-improved))
   #+end_src

** IDL

   Old and trustful data processing language.

   #+BEGIN_SRC emacs-lisp
     (setq idlwave-block-indent 4
           idlwave-end-offset -4
           idlwave-indent-parens-nested t)
   #+END_SRC

** Groovy

   Java groovy configurations.

   #+BEGIN_SRC emacs-lisp
     ;;; use groovy-mode when file ends in .groovy or has #!/bin/groovy at start
     ;;; note: needed sudo apt-get install bzr
     (add-to-list
      'el-get-sources
      '(:name groovy-emacs-mode :after
              (progn 
                (add-to-list 'auto-mode-alist '("\.groovy$" . groovy-mode))
                (add-to-list 'interpreter-mode-alist '("groovy" . groovy-mode))
                )))
   #+END_SRC

** Promela
   Spin model checker uses promela as its programming language  
   
   #+begin_src emacs-lisp
     (autoload 'promela-mode "promela-mode" "PROMELA mode" nil t)
     (setq auto-mode-alist
           (append
            (list (cons "\\.promela$"  'promela-mode)
                  (cons "\\.spin$"     'promela-mode)
                  (cons "\\.pml$"      'promela-mode)
                  ;; (cons "\\.other-extensions$"     'promela-mode)
                  )
            auto-mode-alist))
   #+end_src
** javascript

   Nodejs is installed/downloaded outside emacs frame,

   #+BEGIN_SRC sh
     sudo apt-get install nodejs npm
   #+END_SRC

   flymake-jslint, flymake-cursor and js2-mode are installed from elpa
   and configured.

   #+BEGIN_SRC emacs-lisp
     ;;(add-to-list 'interpreter-mode-alist '("spidermonkey" . js2-mode))
     
     ;; (require 'js-comint) 
     (add-to-list 
      'el-get-sources 
      '(:name js-comint :type elpa 
              :after 
              (progn
                (setq inferior-js-program-command "/usr/bin/js")
                (add-hook 'js2-mode-hook 
                          '(lambda ()
                             (local-set-key "\C-x\C-e" 'js-send-last-sexp)
                             (local-set-key "\C-\M-x" 'js-send-last-sexp-and-go)
                             (local-set-key "\C-cb" 'js-send-buffer)
                             (local-set-key "\C-c\C-b" 'js-send-buffer-and-go)
                             (local-set-key "\C-cl" 'js-load-file-and-go)
                             ))
                )))
     (add-to-list 
      'el-get-sources 
      '(:name js2-mode :type elpa
              :after 
              (progn
                (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
                )))
     
     ;;todo enable
     ;;(require 'flymake-jslint)
     ;;(add-hook 'js-mode-hook 'flymake-jslint-load)
   #+END_SRC
** JSON
   
   JSON pretty printing can be accomplished with following mode.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'el-get-sources
                  '(:name json-reformat))
   #+END_SRC

** HTML

   Handlebars template file suffix should auto load =html-mode=. 

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.hbs\\'" . html-mode))
   #+END_SRC

** DONE Clojure
   Lisp dialect that runs on JVM. Needs external clojure
   installation. For clojureI use CIDER package collection.

   For cider to work properly one needs to add following configuration
   into [[~/.lein/profiles.clj][leinegen profile.]]

   #+BEGIN_SRC clojure :tangle no
     {:user {:plugins [[cider/cider-nrepl "0.9.0-SNAPSHOT"]]}}
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'el-get-sources
                  '(:name cider))
   #+END_SRC

*** Clojurescript

    To plug clojurescript tool figwheel into nrepl and run cljs repl
    from the emacs buffer we can use following snippet to start it
    when cider nrepl is opened particular project. See [[https://github.com/bhauman/lein-figwheel/wiki/Using-the-Figwheel-REPL-within-NRepl][Lein figwheel
    documentation]].
    
    #+BEGIN_SRC emacs-lisp
      (defun cider-figwheel-repl ()
        (interactive)
        (save-some-buffers)
        (with-current-buffer (cider-current-repl-buffer)
          (goto-char (point-max))
          (insert "(require 'figwheel-sidecar.repl-api)
                 (figwheel-sidecar.repl-api/start-figwheel!)
                 (figwheel-sidecar.repl-api/cljs-repl)")
          (cider-repl-return)))
    #+END_SRC

** Graphviz

   #+BEGIN_SRC emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name graphviz-dot-mode :type elpa))
   #+END_SRC

** Slime

   Superior Lisp mode.

   #+begin_src emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name slime :features slime
              :after
              (progn
                (setq inferior-lisp-program "/usr/bin/sbcl")
                (slime-setup '(slime-fancy slime-indentation))
                )))
     
     (provide 'programming)
   #+end_src

* Browsers 						       :internet:dev:
  :PROPERTIES:
  :tangle: personal/browsers.el
  :END:

  Here be variables and things related to emacs-to-internet consept.
  Should build function that asks which browers to start (ff/w3c)

  #+BEGIN_SRC emacs-lisp
    ;;; browsers.el --- utilities to integrate browser actions to emacs buffers 
    
    
    (add-to-el-sources
     w3m
     builtin
     (progn ;TODO global-set-keys are not working...(in org mode??)
       (global-set-key (kbd "C-x C-f") 'search-in-internet)
       (global-set-key (kbd "C-x C-m") 'browse-url-at-point) ;;FUCKING REMEMBER THIS!!@!!
       (setq w3m-use-cookies t)
       (lexical-let ((available-browsers '(
                                           ("default" browse-url-default-browser)
                                           ("firefox" browse-url-firefox)
                                           ("w3m" w3m-browse-url))))
         (setq browse-url-browser-function 
               (lambda(url &optional new-window)
                 (interactive)
                 (funcall 
                  (cadr 
                   (assoc 
                    (read-string 
                     "Select Browser: " 
                     (caar available-browsers)
                     nil
                     (mapcar 'car available-browsers)) available-browsers))
                  url new-window))))
       ))
   #+END_SRC

** The custom search URLs
   :PROPERTIES:
   :ID:       034e629c-2adc-47ce-aeeb-85e9f4436e8e
   :END:
   Function that applies marked region to google search.

   #+BEGIN_SRC emacs-lisp
     ;; Variables
     (defvar *internet-search-urls*
       (quote ("http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
               "http://en.wikipedia.org/wiki/Special:Search?search="
               "http://perldoc.perl.org/search.html?q=")))
     
     ;;; Search a query on the Internet using the selected URL.
     (defun search-in-internet (arg)
       "Searches the internet using the ARGth custom URL for the marked
      text. If a region is not selected, prompts for the string to search
      on. The prefix number ARG indicates the Search URL to use. By default
      the search URL at position 1 will be used."
       (interactive "p")
     
       ;; Some sanity check.
       (if (> arg (length *internet-search-urls*))
           (error "There is no search URL defined at position %s" arg))
     
       (let ((query                          ; Set the search query first.
              (if (region-active-p)
                  (buffer-substring (region-beginning) (region-end))
                (read-from-minibuffer "Search for: ")))
     
             ;; Now get the Base URL to use for the search
             (baseurl (nth (1- arg) *internet-search-urls*)))
     
         ;; Add the query parameter
         (let ((url
                (if (string-match "%s" baseurl)
                    ;; If the base URL has a %s embedded, then replace it
                    (replace-match query t t baseurl)
                  ;; Else just append the query string at end of the URL
                  (concat baseurl query))))
     
           (message "Searching for %s at %s" query url)
           ;; Now browse the URL
           (browse-url url))))
     
     (defun wiki-search ()
       (search-in-internet 2))
     
     (defun perldoc-search ()
       (search-in-internet 3))
     
     (provide 'browsers)
   #+END_SRC
   
* TODO ElNode						 :services:async:tcp:
  :PROPERTIES:
  :tangle: personal/el-node-services.el
  :END:

  Elnode is a library that enables emacs to expose itself as user
  defined web services.

  - dependencies needs to be defined here 

  #+BEGIN_SRC emacs-lisp
    ;;; el-node-services.el --- Example usage of el-node library
    
    (add-to-list
     'el-get-sources
     '(:name elnode :features elnode
             :after 
             (progn
               (global-set-key (kbd "<C-f12>") 'elnode-init-services)
               (global-set-key (kbd "<C-S-f12>") 'elnode-stop-services)    
               )))
  #+end_src

** Utility tools
   Used to Store and retrieve configuration data of services.

   #+begin_src emacs-lisp
     (defun elnode-add-service-to-init (handler port host)
       (setq elnode-local-handlers (add-to-list 'elnode-local-handlers handler))
       (setplist handler (list :port port :host host)))
     
     (defun get-elnode-local-handlers ()
       elnode-local-handlers)
     
     ;; initialize handler list   
     (setq elnode-local-handlers '())
   #+end_src

** Services
   Here is definition of the service initialization.

   #+begin_src emacs-lisp
     (defun elnode-init-services()
       "Starts all defined elnode tcp services. These services are
          defined in configuration file, but can be added/modified any
          time."
       (interactive)
       (message "Starting elnode services...")
       (mapc 
        (lambda (request-handler)
          (elnode-start request-handler (get request-handler :port) (get request-handler :host)))
        (get-elnode-local-handlers))
        (message "elnode: Starting done."))
          
     (defun elnode-stop-services()
       "Stopping all services defined in elnode-local-handlers list"
       (interactive)
       (message "Stopping elnode services...")
       (mapc 
        (lambda (request-handler)
          (elnode-stop (get request-handler :port)))
        (get-elnode-local-handlers))
       (message "elnode: Stopping done."))     
   #+end_src

*** Simple Example service
    This is the simplest example possible, hello world.

    #+begin_src emacs-lisp
      (defun nicferrier-handler (httpcon)
        "Demonstration function"
        (elnode-http-start httpcon "200" '("Content-type" . "text/html"))
        (elnode-http-return httpcon "<html><b>HELLO!</b></html>"))
      (elnode-add-service-to-init 'nicferrier-handler 8010 "localhost")
    #+end_src
*** Complex Example service
    This is a example service that can be provided by this little editor,

    #+BEGIN_SRC emacs-lisp
      (defun orgexpose (httpcon)
        (save-excursion
          (org-export-as-xoxo (get-buffer "school.org"))
          (elnode-http-start httpcon "200" '("Content-type" . "text/html"))
          (elnode-http-return 
           httpcon
           (format "<html>%s</html>" 
                   (with-current-buffer (get-buffer "school.html")
                     (buffer-substring-no-properties (point-min) (point-max)))))))
      (elnode-add-service-to-init 'orgexpose 8020 "localhost")
      
      (provide 'el-node-services)
    #+END_SRC
* Consoles							    :console:
  :PROPERTIES:
  :tangle: personal/consoles.el
  :END:

  First we need to define some features, such as colors and
  completion, which we want to our shells.

  #+BEGIN_SRC emacs-lisp
    ;;; consoles.el --- Several different console configuration
    (setq explicit-bash-args '("--noediting" "-i" "-l"))
    
    (add-to-list
     'el-get-sources
     '(:name shell-completion :features shell-completion))
  #+END_SRC

** SQL 							   :database:
   Defines customization of the SQL mode. This is very poverfull mode
   for integrating SQL database actions to emacs.

*** Keybinding							       :keys:
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "<f9>") 'sql-mysql)
    #+END_SRC
*** Hooks
    #+BEGIN_SRC emacs-lisp
      (add-hook 'sql-interactive-mode 'toggle-truncate-lines)
    #+END_SRC
** Multiterm 							      :shell:
   :PROPERTIES:
   :tangle:   no
   :END:
   My new terminal manager. There is couple of copy/paste issues and
   backspacing that renders this quite useless in my usage.

   #+BEGIN_SRC emacs-lisp
     (add-to-list
      'el-get-sources
      '(:name multi-term :features multi-term
              :after (progn
                       (global-set-key (kbd "<C-f8>") 'multi-term)
                       (setq multi-term-program "/bin/bash"
                             multi-term-shell-arguments "-l"
                             multi-term-buffer-name "bash-shell"))))
   #+END_SRC

** TODO eshell							   :RESEARCH:
   You should get familiarized with eshell
** git 								:VCS:
   
   Here is defined git-emacs interface customization. Currently I'm
   using magit.

*** magit Configuration

    #+BEGIN_SRC emacs-lisp
      (add-to-list
       'el-get-sources
       '(:name magit :type elpa
               :after
               (progn
                 (global-set-key (kbd "<f10>") 'magit-status))
               ))
    #+END_SRC

*** git-gutter
    
    Enable git gutter sublime fork mode so that I can visualize diff
    against GIT head.
    
    #+begin_src emacs-lisp 
      (add-to-el-sources
       git-gutter
       elpa 
       (progn
        (global-git-gutter-mode t)
        (global-set-key (kbd "C-x C-g") 'git-gutter:toggle)
        (global-set-key (kbd "C-x v =") 'git-gutter:popup-hunk)
      
        (global-set-key (kbd "C-x p") 'git-gutter:previous-hunk)
        (global-set-key (kbd "C-x n") 'git-gutter:next-hunk)
      
        (global-set-key (kbd "C-x r") 'git-gutter:revert-hunk)))
    #+end_src

** Bash-shell							   :obsolete:
   This has been made obsolete by Multiterm package.
*** Keybinding							       :keys:

    #+BEGIN_SRC emacs-lisp
      (global-set-key [f8] 'alt-shell-dwim)
      (global-set-key (kbd "M-r") 'shell-resync-dirs)
    #+END_SRC
*** Other
    #+BEGIN_SRC emacs-lisp
      (defun alt-shell-dwim (arg)
        "Run an inferior shell like `shell'. If an inferior shell as its I/O
      through the current buffer, then pop the next buffer in `buffer-list'
      whose name is generated from the string \"*shell*\". When called with
      an argument, start a new inferior shell whose I/O will go to a buffer
      named after the string \"*shell*\" using `generate-new-buffer-name'."
        (interactive "P")
        (let* ((shell-buffer-list
               (let (blist)
                  (dolist (buff (buffer-list) blist)
                    (when (string-match "^\\*shell\\*" (buffer-name buff))
                     (setq blist (cons buff blist))))))
               (name (if arg
                        (generate-new-buffer-name "*shell*")
                      (car shell-buffer-list))))
          (shell name)))
      
      (provide 'consoles)      
     #+END_SRC
* Emacs customization						  :customize:
  Here we define and load the file where customization is kept.

  #+begin_src emacs-lisp
    (require 'appearance)
    ;; in separate variable so that emacs can find sexp where to add things.
    (setq custom-file "~/.emacs-custom.el") 
    (load custom-file 'noerror)
  #+end_src

* Loading of different aspects				       :finalization:

  Here I then load these personalization modules to my emacs at
  startup. I intentionally left some modules unloaded, because they
  are so rarely used.

  #+begin_src emacs-lisp
    ;; here are headline categorized configs as simple modules... 
    (require 'navigation)
    (require 'editing)
    (require 'buffers)
    (require 'mailing)
    (require 'erc-customs)
    (require 'browsers)

    (require 'consoles)
    (require 'programming)
    (require 'org-personal)
  #+end_src

** syncing el-get packages

   Here we synchronize sync all previously defined packages that were
   declared in this configuration file. 

   #+begin_src emacs-lisp
     (setq my-el-get-packages
           (append
            (mapcar 'el-get-source-name el-get-sources)))
     (el-get 'sync my-el-get-packages)

     ;; emacs own package manager will be loaded _after_ el-get...
     (package-initialize)
   #+end_src

* License							    :license:

  Used external libraries are licensed as they are described in their
  source files. This file and its generated derivatives are licensed
  by following license:

  "This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3, or (at your option)
  any later version.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; see the file COPYING.  If not, write to the
  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  Boston, MA 02110-1301, USA."

  If you notice some license violations in this repository, please
  contact original author of this repository.
